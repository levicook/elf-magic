use crate::domain::{ElfMagicError, SolanaProgram};
use minijinja::{context, Environment};

/// Template for the generated lib.rs file
const LIB_TEMPLATE: &str = r#"
// This file is auto-generated by elf-magic
// DO NOT EDIT MANUALLY - Changes will be overwritten
// Generated at: {{ timestamp }}

{% for constant in constants -%}
/// ELF binary for the {{ constant.program_name }} Solana program
pub const {{ constant.name }}: &[u8] = include_bytes!(env!("{{ constant.env_var }}"));

{% endfor -%}

/// Get all available Solana program ELF binaries
/// Returns a vector of (program_name, elf_bytes) tuples
pub fn elves() -> Vec<(&'static str, &'static [u8])> {
    vec![
{% for constant in constants -%}
        ("{{ constant.program_name }}", {{ constant.name }}),
{% endfor -%}
    ]
}
"#;

/// Render the complete lib.rs file content from Solana programs
///
/// This is the main entry point for code generation - takes domain objects
/// and produces the final formatted Rust code using templates.
pub fn render_lib_file(programs: &[SolanaProgram]) -> Result<String, ElfMagicError> {
    // Convert programs to template data
    let template_data = programs
        .iter()
        .map(|program| {
            serde_json::json!({
                "name": program.constant_name(),
                "env_var": program.env_var_name(),
                "program_name": program.name.clone()
            })
        })
        .collect::<Vec<_>>();

    // Create minijinja environment and render template
    let mut env = Environment::new();
    env.add_template("lib", LIB_TEMPLATE)
        .map_err(|e| ElfMagicError::CodeGeneration(format!("Failed to add template: {}", e)))?;

    let template = env
        .get_template("lib")
        .map_err(|e| ElfMagicError::CodeGeneration(format!("Failed to get template: {}", e)))?;

    let rendered_content = template
        .render(context! {
            constants => template_data,
            timestamp => chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC").to_string()
        })
        .map_err(|e| ElfMagicError::CodeGeneration(format!("Failed to render template: {}", e)))?;

    Ok(rendered_content)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_render_lib_file() {
        // Create test programs
        let programs = vec![
            SolanaProgram {
                name: "token-manager".to_string(),
                path: PathBuf::from("programs/token-manager"),
                manifest_path: PathBuf::from("programs/token-manager/Cargo.toml"),
            },
            SolanaProgram {
                name: "governance".to_string(),
                path: PathBuf::from("programs/governance"),
                manifest_path: PathBuf::from("programs/governance/Cargo.toml"),
            },
        ];

        // Test template rendering
        let result = render_lib_file(&programs);
        assert!(result.is_ok());

        let rendered_content = result.unwrap();

        // Verify key content is present
        assert!(rendered_content.contains("auto-generated by elf-magic"));
        assert!(rendered_content.contains("TOKEN_MANAGER_ELF"));
        assert!(rendered_content.contains("GOVERNANCE_ELF"));
        assert!(rendered_content
            .contains("include_bytes!(env!(\"PROGRAM_TOKEN_MANAGER_ELF_MAGIC_PATH\"))"));
        assert!(rendered_content
            .contains("include_bytes!(env!(\"PROGRAM_GOVERNANCE_ELF_MAGIC_PATH\"))"));
        assert!(rendered_content.contains("pub fn elves()"));
        assert!(rendered_content.contains("(\"token-manager\", TOKEN_MANAGER_ELF)"));
        assert!(rendered_content.contains("(\"governance\", GOVERNANCE_ELF)"));
    }

    #[test]
    fn test_render_lib_file_empty_constants() {
        let programs: Vec<SolanaProgram> = Vec::new();

        let result = render_lib_file(&programs);
        assert!(result.is_ok());

        let rendered_content = result.unwrap();

        // Should still generate valid file with empty vector
        assert!(rendered_content.contains("auto-generated by elf-magic"));
        assert!(rendered_content.contains("pub fn elves()"));
        assert!(rendered_content.contains("vec!["));
        assert!(rendered_content.contains("]"));

        // Should not contain any constants
        assert!(!rendered_content.contains("pub const"));
        assert!(!rendered_content.contains("include_bytes!"));
    }

    #[test]
    fn test_render_lib_file_no_template_artifacts() {
        // Test that template rendering produces clean output
        let programs = vec![SolanaProgram {
            name: "test-program".to_string(),
            path: PathBuf::from("programs/test-program"),
            manifest_path: PathBuf::from("programs/test-program/Cargo.toml"),
        }];

        let result = render_lib_file(&programs);
        assert!(result.is_ok());

        let rendered_content = result.unwrap();

        // Verify the content looks like valid Rust
        assert!(rendered_content.contains("pub const TEST_PROGRAM_ELF"));
        assert!(rendered_content.contains("include_bytes!"));
        assert!(rendered_content.contains("pub fn elves()"));

        // Should not have any obvious template syntax left
        assert!(!rendered_content.contains("{{"));
        assert!(!rendered_content.contains("}}"));
        assert!(!rendered_content.contains("{%"));
        assert!(!rendered_content.contains("%}"));
    }
}
