use crate::domain::{BuiltProgram, ConstantDefinition, GeneratedCode};

/// Generate the complete lib.rs file content from built programs
///
/// This is a pure function that takes built programs and generates
/// clean Rust code with constants and helper functions.
pub fn generate_lib_code(built_programs: &[BuiltProgram]) -> GeneratedCode {
    let constants = built_programs
        .iter()
        .map(|program| ConstantDefinition {
            name: program_constant_name(&program.program.name),
            env_var: program.env_var_name.clone(),
        })
        .collect();

    GeneratedCode::new(constants)
}

/// Generate the file header with warning comments
pub fn generate_file_header() -> String {
    r#"// Generated by elf-magic - DO NOT EDIT THIS FILE!
//
// This file is automatically generated during the build process.
// Any manual changes will be overwritten on the next build.
// 
// To modify the programs included, edit your build.rs file or
// update the program discovery configuration.

"#
    .to_string()
}

/// Generate a constant definition line
///
/// Produces: `pub const TOKEN_MANAGER_ELF: &[u8] = include_bytes!(env!("PROGRAM_TOKEN_MANAGER_ELF_MAGIC_PATH"));`
pub fn generate_constant_definition(constant: &ConstantDefinition) -> String {
    // TODO: Generate the include_bytes! line with proper formatting
    todo!("implement generate_constant_definition")
}

/// Generate the all_programs() helper function
///
/// Creates a function that returns all programs as (name, bytes) tuples
pub fn generate_all_programs_function(constants: &[ConstantDefinition]) -> String {
    if constants.is_empty() {
        return "pub fn all_programs() -> Vec<(&'static str, &'static [u8])> {\n    vec![]\n}"
            .to_string();
    }

    // TODO: Generate function body with all constants
    // TODO: Convert CONSTANT_NAME back to original program name for tuples
    todo!("implement generate_all_programs_function")
}

/// Convert program name to constant name
///
/// "token-manager" -> "TOKEN_MANAGER_ELF"
pub fn program_constant_name(program_name: &str) -> String {
    // TODO: Convert kebab-case to SCREAMING_SNAKE_CASE and add _ELF suffix
    todo!("implement program_constant_name")
}

/// Convert constant name back to program name for all_programs function
///
/// "TOKEN_MANAGER_ELF" -> "token_manager"
pub fn constant_to_program_name(constant_name: &str) -> String {
    // TODO: Convert SCREAMING_SNAKE_CASE back to snake_case, remove _ELF suffix
    todo!("implement constant_to_program_name")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::domain::{BuiltProgram, SolanaProgram};
    use std::path::PathBuf;

    #[test]
    fn test_generate_lib_code_empty() {
        let built_programs = vec![];
        let code = generate_lib_code(&built_programs);
        assert!(code.constants.is_empty());
        assert!(code.all_programs_fn.contains("vec![]"));
    }

    #[test]
    fn test_generate_file_header() {
        let header = generate_file_header();
        assert!(header.contains("DO NOT EDIT"));
        assert!(header.contains("elf-magic"));
    }

    #[test]
    fn test_program_constant_name() {
        // TODO: Test name conversion
        // assert_eq!(program_constant_name("token-manager"), "TOKEN_MANAGER_ELF");
        todo!("implement test")
    }

    #[test]
    fn test_constant_to_program_name() {
        // TODO: Test reverse conversion
        // assert_eq!(constant_to_program_name("TOKEN_MANAGER_ELF"), "token_manager");
        todo!("implement test")
    }

    #[test]
    fn test_generate_constant_definition() {
        // TODO: Test constant generation
        todo!("implement test")
    }
}
